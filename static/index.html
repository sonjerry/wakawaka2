<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC카 조종기</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .video-container {
            flex: 1;
            background: #111;
            position: relative;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .status-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected { background: #4CAF50; }
        .status-connecting { background: #ff9800; animation: pulse 1s infinite; }
        .status-disconnected { background: #f44336; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .dashboard {
            height: 100px;
            background: #333;
            border-top: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: monospace;
        }

        .control-info {
            text-align: center;
        }

        .control-info h3 {
            margin-bottom: 10px;
            color: #4CAF50;
        }

        .control-info p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-container">
            <video id="videoElement" autoplay muted playsinline></video>
            <div class="status-overlay">
                <span class="status-indicator status-disconnected" id="statusIndicator"></span>
                <span id="connectionStatus">연결 대기 중...</span>
            </div>
        </div>
        <div class="dashboard">
            <div class="control-info">
                <h3>RC카 조종기</h3>
                <p>WASD 키로 조종하세요</p>
                <p id="streamInfo">스트림 정보: --</p>
            </div>
        </div>
    </div>

    <script>
        class RCController {
            constructor() {
                this.videoElement = document.getElementById('videoElement');
                this.statusIndicator = document.getElementById('statusIndicator');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.streamInfo = document.getElementById('streamInfo');
                
                this.pc = null;
                this.websocket = null;
                this.isConnected = false;
                
                this.init();
            }

            async init() {
                this.setupEventListeners();
                await this.connectWebRTC();
            }

            setupEventListeners() {
                // 키보드 이벤트
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
            }

            async connectWebRTC() {
                try {
                    // MediaMTX WebRTC 연결
                    this.connectToMediaMTX();
                } catch (error) {
                    console.error('WebRTC 연결 오류:', error);
                    this.updateStatus('disconnected', '연결 실패');
                }
            }

            async connectToMediaMTX() {
                try {
                    this.updateStatus('connecting', 'MediaMTX 연결 중...');
                    
                    // MediaMTX WebRTC 엔드포인트
                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });
                    
                    // 비디오 스트림 처리
                    pc.ontrack = (event) => {
                        console.log('비디오 스트림 수신');
                        this.videoElement.srcObject = event.streams[0];
                        this.updateStatus('connected', '연결됨');
                        this.updateStreamInfo('1280x720 @ 30fps');
                    };
                    
                    // ICE Candidate 처리
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            // MediaMTX는 자동으로 ICE Candidate 처리
                            console.log('ICE Candidate:', event.candidate);
                        }
                    };
                    
                    // 연결 상태 모니터링
                    pc.onconnectionstatechange = () => {
                        console.log('연결 상태:', pc.connectionState);
                        if (pc.connectionState === 'connected') {
                            this.isConnected = true;
                        }
                    };
                    
                    // MediaMTX WebRTC 스트림 요청 (WHEP 사용)
                    console.log('MediaMTX WHEP 엔드포인트에 연결 시도 중...');
                    
                    // 먼저 스트림이 있는지 확인
                    const streamCheck = await fetch('http://100.84.162.124:9997/v3/paths/list');
                    if (!streamCheck.ok) {
                        throw new Error('MediaMTX API에 연결할 수 없습니다');
                    }
                    
                    const streams = await streamCheck.json();
                    console.log('사용 가능한 스트림:', streams);
                    
                    if (!streams.items || streams.items.length === 0) {
                        throw new Error('스트림이 없습니다. FFmpeg으로 스트림을 먼저 시작하세요');
                    }
                    
                    const response = await fetch('http://100.84.162.124:8889/whep', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/sdp'
                        },
                        body: await pc.createOffer().then(offer => {
                            pc.setLocalDescription(offer);
                            return offer.sdp;
                        })
                    });
                    
                    console.log('MediaMTX 응답 상태:', response.status);
                    console.log('MediaMTX 응답 헤더:', response.headers);
                    
                    if (response.ok) {
                        const answerSdp = await response.text();
                        console.log('MediaMTX Answer SDP 수신:', answerSdp.substring(0, 100) + '...');
                        
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: answerSdp
                        }));
                        console.log('MediaMTX WebRTC 연결 성공');
                    } else {
                        const errorText = await response.text();
                        console.error('MediaMTX 연결 실패:', response.status, errorText);
                        throw new Error(`MediaMTX 연결 실패: ${response.status} - ${errorText}`);
                    }
                    
                } catch (error) {
                    console.error('MediaMTX 연결 오류:', error);
                    this.updateStatus('disconnected', 'MediaMTX 연결 실패');
                }
            }

            async handleWebSocketMessage(message) {
                const { type, data } = message;
                
                switch (type) {
                    case 'offer':
                        await this.handleOffer(data);
                        break;
                    case 'ice-candidate':
                        await this.handleIceCandidate(data);
                        break;
                }
            }

            async handleOffer(offerData) {
                try {
                    // RTCPeerConnection 생성
                    this.pc = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });
                    
                    // 비디오 스트림 처리
                    this.pc.ontrack = (event) => {
                        console.log('비디오 스트림 수신');
                        this.videoElement.srcObject = event.streams[0];
                        this.updateStatus('connected', '연결됨');
                        this.updateStreamInfo('1280x720 @ 30fps');
                    };
                    
                    // ICE Candidate 처리
                    this.pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.sendWebSocketMessage({
                                type: 'ice-candidate',
                                data: {
                                    candidate: event.candidate.candidate,
                                    sdpMLineIndex: event.candidate.sdpMLineIndex
                                }
                            });
                        }
                    };
                    
                    // 연결 상태 모니터링
                    this.pc.onconnectionstatechange = () => {
                        console.log('연결 상태:', this.pc.connectionState);
                        if (this.pc.connectionState === 'connected') {
                            this.isConnected = true;
                        }
                    };
                    
                    // Offer 설정
                    await this.pc.setRemoteDescription(new RTCSessionDescription(offerData));
                    
                    // Answer 생성
                    const answer = await this.pc.createAnswer();
                    await this.pc.setLocalDescription(answer);
                    
                    // Answer 전송
                    this.sendWebSocketMessage({
                        type: 'answer',
                        data: {
                            type: answer.type,
                            sdp: answer.sdp
                        }
                    });
                    
                    console.log('Answer 전송 완료');
                    
                } catch (error) {
                    console.error('Offer 처리 오류:', error);
                    this.updateStatus('disconnected', 'Offer 처리 실패');
                }
            }

            async handleIceCandidate(candidateData) {
                if (this.pc) {
                    try {
                        await this.pc.addIceCandidate(new RTCIceCandidate(candidateData));
                        console.log('ICE Candidate 추가됨');
                    } catch (error) {
                        console.error('ICE Candidate 처리 오류:', error);
                    }
                }
            }

            sendWebSocketMessage(message) {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify(message));
                }
            }

            handleKeyDown(event) {
                if (!this.isConnected) return;
                
                event.preventDefault();
                const key = event.key.toLowerCase();
                
                if (['w', 'a', 's', 'd', ' '].includes(key)) {
                    this.sendControlCommand(key, true);
                }
            }

            handleKeyUp(event) {
                if (!this.isConnected) return;
                
                event.preventDefault();
                const key = event.key.toLowerCase();
                
                if (['w', 'a', 's', 'd', ' '].includes(key)) {
                    this.sendControlCommand(key, false);
                }
            }

            sendControlCommand(key, isActive) {
                const commands = {
                    'w': 'forward',
                    's': 'backward',
                    'a': 'left',
                    'd': 'right',
                    ' ': 'stop'
                };
                
                const command = commands[key];
                const action = isActive ? 'start' : 'stop';
                
                console.log(`제어 명령: ${command} ${action}`);
                
                // Flask API로 제어 명령 전송
                fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        command: command,
                        action: action,
                        timestamp: Date.now()
                    })
                }).catch(error => console.error('제어 명령 전송 오류:', error));
            }

            updateStatus(status, message) {
                this.statusIndicator.className = `status-indicator status-${status}`;
                this.connectionStatus.textContent = message;
            }

            updateStreamInfo(info) {
                this.streamInfo.textContent = `스트림 정보: ${info}`;
            }
        }

        // 페이지 로드 시 컨트롤러 초기화
        document.addEventListener('DOMContentLoaded', () => {
            new RCController();
        });
    </script>
</body>
</html>